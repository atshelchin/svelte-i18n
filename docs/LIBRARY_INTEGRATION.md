# Library Integration Guide

## For Library Authors Using @shelchin/svelte-i18n

If you're developing a library that uses @shelchin/svelte-i18n, follow these conventions to ensure your library's translations can be properly validated by consuming applications.

### 1. Standard Type Export

Your library should export its i18n types in a standard location. Add this to your `package.json`:

```json
{
	"name": "your-library",
	"exports": {
		".": "./dist/index.js",
		"./i18n-types": "./dist/types/i18n-generated.d.ts"
	}
}
```

### 2. Generate Types During Build

Add type generation to your build process:

```json
{
	"scripts": {
		"build": "npm run generate-types && vite build",
		"generate-types": "npx @shelchin/svelte-i18n generate-types --mode library"
	}
}
```

### 3. Standard Translation Structure

Place your library's translations at:

```
src/translations/
  └── [your-library-name]/
      ├── en.json    # Required: default language
      ├── zh.json
      └── ...
```

### 4. Export Type Information

Create `src/i18n-meta.ts`:

```typescript
// Export metadata about your library's i18n
export const I18N_META = {
	namespace: 'your-library',
	defaultLocale: 'en',
	typesPath: './i18n-types'
};

// Re-export generated types
export type { I18nPath, I18nKeys } from './types/i18n-generated';
```

## For Applications Consuming Libraries

### Automatic Type Discovery

When validating translations, the CLI will:

1. Check if the package has `./i18n-types` export
2. Import the types and use them for validation
3. Fall back to schema-based validation if types aren't available

### Example Validation Flow

```typescript
// In the CLI tool
async function getPackageTypes(packageName: string) {
	try {
		// Try to import the package's i18n types
		const types = await import(`${packageName}/i18n-types`);
		return types.I18N_PATHS;
	} catch {
		// Fall back to JSON schema validation
		return null;
	}
}
```

## Recommended Package Structure

```
your-library/
├── package.json
├── src/
│   ├── translations/
│   │   └── your-library/
│   │       ├── en.json
│   │       └── zh.json
│   ├── types/
│   │   └── i18n-generated.ts  # Generated by CLI
│   └── i18n-meta.ts           # Metadata export
└── dist/
    ├── types/
    │   └── i18n-generated.d.ts # Built types
    └── i18n-meta.js
```

## Benefits

1. **Type Safety**: Applications can validate against actual TypeScript types
2. **Standardization**: All libraries follow the same pattern
3. **Flexibility**: Libraries can still customize their structure
4. **Backward Compatibility**: Falls back to JSON validation if types aren't available
